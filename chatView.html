<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NT Chat - Encrypted</title>
    <link rel="stylesheet" href="./chatView.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    />
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  </head>
  <body>
    <div class="overlay"></div>
    <div class="chat-container">
      <!-- Sidebar -->
      <div class="chat-sidebar" id="chat-sidebar">
        <div class="sidebar-header">
          <h2>Chats</h2>
          <button class="logout-btn" onclick="logout()">
            <i class="fas fa-sign-out-alt"></i> Log Out
          </button>
        </div>
        <div class="chat-list" id="chat-list"></div>
      </div>

      <!-- Chat -->
      <div class="chat-main" id="chat-main">
        <div class="chat-header" id="chat-header">
          <input
            type="text"
            id="target-username"
            placeholder="Enter username to chat"
            class="chat-user-input"
          />
        </div>
        <div class="chat-messages" id="chat-messages"></div>
        <div class="chat-input">
          <div class="input-wrapper">
            <input
              type="text"
              id="message-input"
              placeholder="Type a message..."
            />
            <button onclick="sendMessage()" class="send-btn">
              <i class="fas fa-paper-plane"></i>
            </button>
          </div>
        </div>
      </div>

      <div class="new-chat-container">
        <button class="new-chat-btn" onclick="loadChatList()">
          <i class="fas fa-comments"></i> New Chat
        </button>
      </div>
    </div>

    <script>
      const token = sessionStorage.getItem("ntchat_token");
      const user = JSON.parse(sessionStorage.getItem("ntchat_user"));

      if (!token || !user || !user.username) {
        window.location.href = "index.html";
      }

      const username = user.username;
      let myPrivateKey, myPublicKey;
      let sharedSecrets = {}; // per-contact shared keys
      const chatData = { users: [] };

      // Socket setup with token auth
      const socket = io("http://localhost:3000/nt_backends_api/v1/socket.io", {
        auth: {
          token,
          username,
        },
        path: "socket.io", // Use correct path
        transports: ["websocket"], // Optional: force websocket
      });

      socket.on("connect_error", (err) => {
        console.error("Socket connection failed:", err.message);
        alert("Session expired or unauthorized. Please log in again.");
        logout();
      });

      async function register() {
        const keys = await window.crypto.subtle.generateKey(
          { name: "ECDH", namedCurve: "P-256" },
          true,
          ["deriveKey"]
        );
        myPrivateKey = keys.privateKey;
        myPublicKey = keys.publicKey;

        const exported = await window.crypto.subtle.exportKey(
          "raw",
          myPublicKey
        );
        const publicKeyB64 = btoa(
          String.fromCharCode(...new Uint8Array(exported))
        );

        socket.emit("register", { username, publicKey: publicKeyB64 });
      }

      async function deriveSharedKey(peerPublicKeyB64) {
        const keyBuffer = Uint8Array.from(atob(peerPublicKeyB64), (c) =>
          c.charCodeAt(0)
        );
        const peerKey = await window.crypto.subtle.importKey(
          "raw",
          keyBuffer,
          { name: "ECDH", namedCurve: "P-256" },
          true,
          []
        );

        return await window.crypto.subtle.deriveKey(
          { name: "ECDH", public: peerKey },
          myPrivateKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt", "decrypt"]
        );
      }

      async function encryptMessage(message, sharedKey) {
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encoded = new TextEncoder().encode(message);
        const ciphertext = await window.crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          sharedKey,
          encoded
        );
        return {
          iv: btoa(String.fromCharCode(...iv)),
          data: btoa(String.fromCharCode(...new Uint8Array(ciphertext))),
        };
      }

      async function decryptMessage({ iv, data }, sharedKey) {
        const ivBytes = Uint8Array.from(atob(iv), (c) => c.charCodeAt(0));
        const dataBytes = Uint8Array.from(atob(data), (c) => c.charCodeAt(0));
        const decrypted = await window.crypto.subtle.decrypt(
          { name: "AES-GCM", iv: ivBytes },
          sharedKey,
          dataBytes
        );
        return new TextDecoder().decode(decrypted);
      }

      // Send encrypted message
      async function sendMessage() {
        const to = document.getElementById("target-username").value.trim();
        const message = document.getElementById("message-input").value.trim();
        if (!to || !message) return;

        if (!sharedSecrets[to]) {
          socket.emit("request_public_key", to);
          socket.once("public_key_response", async ({ publicKey }) => {
            sharedSecrets[to] = await deriveSharedKey(publicKey);
            const encrypted = await encryptMessage(message, sharedSecrets[to]);
            socket.emit("private_message", { to, from: username, encrypted });
            displayMessage("You ", message);
          });
        } else {
          const encrypted = await encryptMessage(message, sharedSecrets[to]);
          socket.emit("private_message", { to, from: username, encrypted });
          displayMessage("You ", message);
        }

        document.getElementById("message-input").value = "";
      }

      // Receive encrypted message
      socket.on("receive_private", async ({ from, encrypted }) => {
        if (!sharedSecrets[from]) {
          socket.emit("request_public_key", from);
          socket.once("public_key_response", async ({ publicKey }) => {
            sharedSecrets[from] = await deriveSharedKey(publicKey);
            const message = await decryptMessage(
              encrypted,
              sharedSecrets[from]
            );
            displayMessage(from, message);
          });
        } else {
          const message = await decryptMessage(encrypted, sharedSecrets[from]);
          displayMessage(from, message);
        }
      });

      function displayMessage(sender, message) {
        const chatMessages = document.getElementById("chat-messages");
        const msgDiv = document.createElement("div");
        msgDiv.classList.add(
          "message",
          sender === "You" ? "message-sent" : "message-received"
        );
        msgDiv.innerHTML = `
          <p>${message}</p>
          <span class="timestamp">${new Date().toLocaleTimeString()}</span>
        `;
        chatMessages.appendChild(msgDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      document
        .getElementById("message-input")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") sendMessage();
        });

      async function loadChatList() {
        try {
          const res = await fetch(
            "http://127.0.0.1:3000/nt_backends_api/v1/getchats",
            {
              method: "GET",
              headers: {
                Authorization: `Bearer ${token}`,
                "Content-Type": "application/json",
              },
            }
          );

          if (!res.ok) throw new Error("Unauthorized or expired session");

          const data = await res.json();
          chatData.users = data.users;
          const chatList = document.getElementById("chat-list");
          chatList.innerHTML = "";

          chatData.users.forEach((user) => {
            const div = document.createElement("div");
            div.classList.add("chat-item");
            div.innerHTML = `<div class="chat-info"><h4>${user.name}</h4><p>${
              user.lastMessage || ""
            }</p></div>`;
            div.onclick = () => {
              document.getElementById("target-username").value = user.name;
              document.getElementById("chat-main").style.display = "flex";
            };
            chatList.appendChild(div);
          });
        } catch (err) {
          alert(err.message);
          //logout();
        }
      }

      function logout() {
        fetch("http://127.0.0.1:3000/nt_backends_api/v1/signout", {
       
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        }).finally(() => {
          sessionStorage.clear();
          window.location.href = "./index.html";
        });
      }
      register();
      loadChatList();
    </script>
  </body>
</html>